{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { UnavailabilityError } from '@unimodules/core';\nimport uuidv4 from 'uuid/v4';\nimport NotificationScheduler from \"./NotificationScheduler\";\nexport default function scheduleNotificationAsync(request) {\n  var _request$identifier;\n\n  return _regeneratorRuntime.async(function scheduleNotificationAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (NotificationScheduler.scheduleNotificationAsync) {\n            _context.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('Notifications', 'scheduleNotificationAsync');\n\n        case 2:\n          _context.next = 4;\n          return _regeneratorRuntime.awrap(NotificationScheduler.scheduleNotificationAsync((_request$identifier = request.identifier) != null ? _request$identifier : uuidv4(), request.content, parseTrigger(request.trigger)));\n\n        case 4:\n          return _context.abrupt(\"return\", _context.sent);\n\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction parseTrigger(userFacingTrigger) {\n  if (userFacingTrigger === null) {\n    return null;\n  }\n\n  if (userFacingTrigger === undefined) {\n    throw new TypeError('Encountered an `undefined` notification trigger. If you want to trigger the notification immediately, pass in an explicit `null` value.');\n  }\n\n  if (isDateTrigger(userFacingTrigger)) {\n    return parseDateTrigger(userFacingTrigger);\n  } else if (isDailyTriggerInput(userFacingTrigger)) {\n    var hour = userFacingTrigger.hour;\n    var minute = userFacingTrigger.minute;\n\n    if (hour === undefined || hour == null || minute === undefined || minute == null) {\n      throw new TypeError('Both hour and minute need to have valid values. Found undefined');\n    }\n\n    if (hour < 0 || hour > 23) {\n      throw new RangeError(\"The hour parameter needs to be between 0 and 23. Found: \" + hour);\n    }\n\n    if (minute < 0 || minute > 59) {\n      throw new RangeError(\"The minute parameter needs to be between 0 and 59. Found: \" + minute);\n    }\n\n    return {\n      type: 'daily',\n      channelId: userFacingTrigger.channelId,\n      hour: hour,\n      minute: minute\n    };\n  } else if (isSecondsPropertyMisusedInCalendarTriggerInput(userFacingTrigger)) {\n    throw new TypeError('Could not have inferred the notification trigger type: if you want to use a time interval trigger, pass in only `seconds` with or without `repeats` property; if you want to use calendar-based trigger, pass in `second`.');\n  } else if ('seconds' in userFacingTrigger) {\n    var _userFacingTrigger$re;\n\n    return {\n      type: 'timeInterval',\n      channelId: userFacingTrigger.channelId,\n      seconds: userFacingTrigger.seconds,\n      repeats: (_userFacingTrigger$re = userFacingTrigger.repeats) != null ? _userFacingTrigger$re : false\n    };\n  } else if (isCalendarTrigger(userFacingTrigger)) {\n    var repeats = userFacingTrigger.repeats,\n        calendarTrigger = _objectWithoutProperties(userFacingTrigger, [\"repeats\"]);\n\n    return {\n      type: 'calendar',\n      value: calendarTrigger,\n      repeats: repeats\n    };\n  } else {\n    return {\n      type: 'channel',\n      channelId: userFacingTrigger.channelId\n    };\n  }\n}\n\nfunction isCalendarTrigger(trigger) {\n  var channelId = trigger.channelId,\n      triggerWithoutChannelId = _objectWithoutProperties(trigger, [\"channelId\"]);\n\n  return Object.keys(triggerWithoutChannelId).length > 0;\n}\n\nfunction isDateTrigger(trigger) {\n  return trigger instanceof Date || typeof trigger === 'number' || typeof trigger === 'object' && trigger['date'];\n}\n\nfunction parseDateTrigger(trigger) {\n  if (trigger instanceof Date || typeof trigger === 'number') {\n    return {\n      type: 'date',\n      timestamp: toTimestamp(trigger)\n    };\n  }\n\n  return {\n    type: 'date',\n    timestamp: toTimestamp(trigger.date),\n    channelId: trigger.channelId\n  };\n}\n\nfunction toTimestamp(date) {\n  if (date instanceof Date) {\n    return date.getTime();\n  }\n\n  return date;\n}\n\nfunction isDailyTriggerInput(trigger) {\n  return Object.keys(trigger).length === 3 && 'hour' in trigger && 'minute' in trigger && 'repeats' in trigger && trigger.repeats === true;\n}\n\nfunction isSecondsPropertyMisusedInCalendarTriggerInput(trigger) {\n  var channelId = trigger.channelId,\n      triggerWithoutChannelId = _objectWithoutProperties(trigger, [\"channelId\"]);\n\n  return 'seconds' in triggerWithoutChannelId && 'repeats' in triggerWithoutChannelId && Object.keys(triggerWithoutChannelId).length > 2 || 'seconds' in triggerWithoutChannelId && !('repeats' in triggerWithoutChannelId) && Object.keys(triggerWithoutChannelId).length > 1;\n}","map":{"version":3,"sources":["../src/scheduleNotificationAsync.ts"],"names":[],"mappings":"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","sourcesContent":["import { UnavailabilityError } from '@unimodules/core';\nimport uuidv4 from 'uuid/v4';\n\nimport NotificationScheduler from './NotificationScheduler';\nimport { NotificationTriggerInput as NativeNotificationTriggerInput } from './NotificationScheduler.types';\nimport {\n  NotificationRequestInput,\n  NotificationTriggerInput,\n  DailyTriggerInput,\n  CalendarTriggerInput,\n  TimeIntervalTriggerInput,\n  DateTriggerInput,\n  ChannelAwareTriggerInput,\n} from './Notifications.types';\n\nexport default async function scheduleNotificationAsync(\n  request: NotificationRequestInput\n): Promise<string> {\n  if (!NotificationScheduler.scheduleNotificationAsync) {\n    throw new UnavailabilityError('Notifications', 'scheduleNotificationAsync');\n  }\n\n  return await NotificationScheduler.scheduleNotificationAsync(\n    request.identifier ?? uuidv4(),\n    request.content,\n    parseTrigger(request.trigger)\n  );\n}\n\nfunction parseTrigger(userFacingTrigger: NotificationTriggerInput): NativeNotificationTriggerInput {\n  if (userFacingTrigger === null) {\n    return null;\n  }\n\n  if (userFacingTrigger === undefined) {\n    throw new TypeError(\n      'Encountered an `undefined` notification trigger. If you want to trigger the notification immediately, pass in an explicit `null` value.'\n    );\n  }\n\n  if (isDateTrigger(userFacingTrigger)) {\n    return parseDateTrigger(userFacingTrigger);\n  } else if (isDailyTriggerInput(userFacingTrigger)) {\n    const hour = userFacingTrigger.hour;\n    const minute = userFacingTrigger.minute;\n    if (hour === undefined || hour == null || minute === undefined || minute == null) {\n      throw new TypeError('Both hour and minute need to have valid values. Found undefined');\n    }\n    if (hour < 0 || hour > 23) {\n      throw new RangeError(`The hour parameter needs to be between 0 and 23. Found: ${hour}`);\n    }\n    if (minute < 0 || minute > 59) {\n      throw new RangeError(`The minute parameter needs to be between 0 and 59. Found: ${minute}`);\n    }\n    return {\n      type: 'daily',\n      channelId: userFacingTrigger.channelId,\n      hour,\n      minute,\n    };\n  } else if (isSecondsPropertyMisusedInCalendarTriggerInput(userFacingTrigger)) {\n    throw new TypeError(\n      'Could not have inferred the notification trigger type: if you want to use a time interval trigger, pass in only `seconds` with or without `repeats` property; if you want to use calendar-based trigger, pass in `second`.'\n    );\n  } else if ('seconds' in userFacingTrigger) {\n    return {\n      type: 'timeInterval',\n      channelId: userFacingTrigger.channelId,\n      seconds: userFacingTrigger.seconds,\n      repeats: userFacingTrigger.repeats ?? false,\n    };\n  } else if (isCalendarTrigger(userFacingTrigger)) {\n    const { repeats, ...calendarTrigger } = userFacingTrigger;\n    return { type: 'calendar', value: calendarTrigger, repeats };\n  } else {\n    // @ts-ignore Type '\"channel\"' is not assignable to type '\"daily\"'.ts(2322)\n    return { type: 'channel', channelId: userFacingTrigger.channelId };\n  }\n}\n\nfunction isCalendarTrigger(\n  trigger: CalendarTriggerInput | ChannelAwareTriggerInput\n): trigger is CalendarTriggerInput {\n  const { channelId, ...triggerWithoutChannelId } = trigger;\n  return Object.keys(triggerWithoutChannelId).length > 0;\n}\n\nfunction isDateTrigger(\n  trigger: DateTriggerInput | DailyTriggerInput | CalendarTriggerInput | TimeIntervalTriggerInput\n): trigger is DateTriggerInput {\n  return (\n    trigger instanceof Date ||\n    typeof trigger === 'number' ||\n    (typeof trigger === 'object' && trigger['date'])\n  );\n}\n\nfunction parseDateTrigger(trigger: DateTriggerInput): NativeNotificationTriggerInput {\n  if (trigger instanceof Date || typeof trigger === 'number') {\n    return { type: 'date', timestamp: toTimestamp(trigger) };\n  }\n  return { type: 'date', timestamp: toTimestamp(trigger.date), channelId: trigger.channelId };\n}\n\nfunction toTimestamp(date: number | Date) {\n  if (date instanceof Date) {\n    return date.getTime();\n  }\n  return date;\n}\n\nfunction isDailyTriggerInput(\n  trigger: DailyTriggerInput | CalendarTriggerInput | TimeIntervalTriggerInput\n): trigger is DailyTriggerInput {\n  return (\n    Object.keys(trigger).length === 3 &&\n    'hour' in trigger &&\n    'minute' in trigger &&\n    'repeats' in trigger &&\n    trigger.repeats === true\n  );\n}\n\nfunction isSecondsPropertyMisusedInCalendarTriggerInput(\n  trigger: TimeIntervalTriggerInput | CalendarTriggerInput\n) {\n  const { channelId, ...triggerWithoutChannelId } = trigger;\n  return (\n    // eg. { seconds: ..., repeats: ..., hour: ... }\n    ('seconds' in triggerWithoutChannelId &&\n      'repeats' in triggerWithoutChannelId &&\n      Object.keys(triggerWithoutChannelId).length > 2) ||\n    // eg. { seconds: ..., hour: ... }\n    ('seconds' in triggerWithoutChannelId &&\n      !('repeats' in triggerWithoutChannelId) &&\n      Object.keys(triggerWithoutChannelId).length > 1)\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}